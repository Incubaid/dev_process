## How do you eat an elephant? One bite at a time!

Likewise, agile development projects are delivered in small bite-sized pieces, delivering small, incremental *releases* and iterating (we call them milestones which do consist out of X stories).

In more traditional software development projects, the (simplified) lifecycle is Analyse, Develop, Test – first gathering all known requirements for the whole product, then developing all elements of the software, then testing that the entire product is fit for release.
In agile software development, the cycle is Analyse, Develop, Test; Analyse, Develop, Test; and so on… doing each step for each feature, one feature at a time.

Advantages of this iterative approach to software development include:

- Reduced risk: clear visibility of what’s completed to date throughout a project
- Increased value: delivering some benefits early; being able to release the product whenever it’s deemed good enough, rather than having to wait for all intended features to be ready
- More flexibility/agility: can choose to change direction or adapt the next iterations based on actually seeing and using the software
- Better cost management: if, like all-too-many software development projects, you run over budget, some value can still be realised; you don’t have to scrap the whole thing if you run short of funds

For this approach to be practical, each feature must be fully developed, to the extent that it’s ready to be shipped, before moving on.

Another practicality is to make sure features are developed in *priority* order, not necessarily in a logical order by function. Otherwise you could run out of time, having built some of the less important features – as in agile software development, the timescales are fixed.

Building the features of the software ”broad but shallow” is also advisable for the same reason. Only when you’ve completed all your must-have features, move on to the should-haves, and only then move on to the could-haves. Otherwise you can get into a situation where your earlier features are functionally rich, whereas later features of the software are increasingly less sophisticated as time runs out.

Try to keep your product backlog or feature list expressed in terms of use cases, user stories, or features – not technical tasks. Ideally each item on the list should always be something of value to the user, and always deliverables rather than activities so you can ‘kick the tyres’ and judge their completeness, quality and readiness for release.

original content from [here](http://www.allaboutagile.com/category/10-key-principles-of-agile/)